Process, Scheculer.

Process: 메인 메모리(RAM)에서 "실행 중"인 프로그램. <- too vague.
         정확히 말하면, 프로세스가 진행하면서 occupy하는 모든 대상(메모리, 가상 메모리, register set...)을 프로세스라고 할 수 있다.
         예를 들어, 프로세스 A와 프로세스 B가 진행할 때 RAM과 cache, 그리고 register set의 데이타들이 달라지므로 모두 프로세스라고 칭할 수 있다.

Context Switching: 프로세스 A에서 프로세스 B로 스위치하는 과정. 바꿀 때에는 프로세스 A에서 사용된 data들로 찬 register set을 다른 곳에 저장해두고 set은 비운 뒤 프로세스 B의 데이타들로 그곳을 채우는 것.
                   참고로 1초에도 수십 번씩 switching이 일어난다. 그래서 context switching 할 때 마다 set을 비우고 채우고 하는 것은 꽤나 부담스런 일이다.
                   그래서 나온 방법이, register set을 여러 개 만들어서 프로세스에 하나의 set을 할당해버리는 것이다. 이러면 CS가 일어나도 set을 비우고 치우는 일은 안 해도 되니까.

Process Scheduler: 둘 이상의 프로세스가 적절히 실행되도록 컨트롤함.
                   CPU는 하나고, 한 번에 하나의 프로세스 밖에 처리를 못하는데 프로세스 여러 개 이므로 프로세스의 순서를 정하고 관리하는 소프트웨어.
                   (논 외: scheduler가 실행 될 때에는 다른 프로세스 실행 불가하다. 그래서 스케줄러는 가급적 조금 활동해야 그 만큼 프로세스들을 많이 쓸 수 있다)

프로세스의 상태: 프로세스는 상태를 가진다. start, ready, running, blocked, end 의 5개의 과정.
                1. 프로그래머가 프로세스를 실행(start)시키면 그게 곧바로 running 되지 않는다. 
                2. 모든 프로세스는 처음에 ready로 향하고, 거기서 스케줄러가 컨펌을 해줘야만 running 상태로 갈 수 있다. 물론 running은 1개의 프로세스 at time만이 할 수 있다.
                3.1 running하는 녀석이 I/O라면, running에 들어오자마자 I/O 연산을 시작한다. I/O 연산은 보통 시간이 걸린다. 
                그런데 다행히도, 얘는 비I/O(사칙연산 등)와는 다르게 CPU가 꼭 있어야만 돌아가는 건 아니니까 I/O 연산이 끝날 때까지는 running에서 물러나서 blocked 상태에 가 있는다.
                그리고 I/O연산이 끝나면 다시 ready 상태로 와서 스케줄러의 선택을 받기로 기다린다.
                3.2 그리고 만약 running하는 애가 I/O가 아니라면, 찔끔 CPU를 사용한 뒤 다음 녀석을 위해 running에서 물러나 다시 ready 상태로 가고, 그렇게 여러 번의 switching을 반복한다.
                4. 다 끝나면 모두 end가 된다.



Thread: 
