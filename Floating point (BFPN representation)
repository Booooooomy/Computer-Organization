Date: Oct. 30, 2018

p106 
**2. 4. 1 비율 이진수(Fractional Binary Numbers)**

기본적으로, Fractional Binary Number의 표시는 다음과 같다.

abcde.fghi(2) 면 이건

a*2^4 + b*2^3 + c*2^2 + d*2^1 + e*2^0 + f*2^(-1) + g*2^(-2) + h*2^(-3) + i*2^(-4) 다.

소수 이진수도 정수 이진수처럼, shift에 의해 2가 곱해지거나 2로 나뉘어지는 효과를 똑같이 가진다.

그리고 0.111111...1(2)와 같은 수는 1의 바로 아래에 있는 수이고, 특별한 notation 1.0 - ε 로 표기할 수 있다.

또, 이진수 표기법으로는 십진수로 표현할 수 있는 모든 수를 완벽히 표현할 수 없다. 예를 들어 1/5 같은 수는 0.2지만 이진법으로는 0.00110011... 이렇게 길게 늘여서 가능한 가까운 수를 찾는 법 뿐이 없다.



**2. 4. 2 IEEE 부동소수점 표시**

부동소수점? 여기서의 부동은 fixed의 '움직이지 않는'이 아니라 'float', 그야말로 '떠다니는'이라는 뜻이다.
소수점이 여기저기 이동할 수 있다는 뜻이다.

우선 표기법은 두 개로 나뉜다. Single precision과 double precision.
Single precision(단정밀도)은 Float datatype을, double precision은 double datatype을 표기한다.


1. Single precision(단정밀도)

기존의 내가 알던 표기법은 큰 수를 표현하기에 비효율적이다. 예를 들어 5 x 2^100 은 101 이후에 100개의 0을 넣어야 한다.
그래서 나온 게 IEEE 부동소수점 표준이다.

- float의 저장

Single precision은 float를 대상으로 한 것이므로 전체가 4byte, 즉 32bit다.
소수는 지수와 가수로 분할되어 아래와 같이 저장된다.

|sign|    Exponent(8) |    Mantissa(23)   |
  31  30            23 22                0

모든 소수를 0.1M * 2 ^ exp 꼴로 바꿔야 single precision으로 표기가 가능하다(normalization).
그리고 M을 unsigned 형태로 Mantissa에 저장하고, S에 부호(음수는 1, 양수는 0)를 저장하고, exp를 Exponent에 2's complement 형태로 저장한다.

ex) 1.1010 x 2^4?
> 이 경우 우선 꼴을 0.11010 x 2^5로 바꿔주자. M = 1010, E = 00000101, S = 0.

- 표현 가능 범위

Mantissa는 이진수 0.1M의 꼴이므로 십진수 변환하면 최소 0.5 이상(0.10000000...이면 0.5)이고, 또 1 이하다(0.1111111...이면 걍 1취급한대)
Exponent는 8자리 2's complement 숫자이므로 범위가 -2^7 초과 2^7 미만이다.
Mantissa는 그러니까 정밀도를 결정하고, Exponent는 좀 더 큰 scope로서 표현 가능한 수의 범위를 결정한다.

그래서 Single Precision BFPN의 표현 가능 범위는 다음과 같다.
절대값이 가장 큰 양수는    0 | 01111111 | 111_1111_1111_1111_1111_1111 이고 그 값은 (1-2^(-24))*2^127 이다.
절대값이 가장 작은 음수는  1 | 10000000 | 000_0000_0000_0000_0000_0000 이므로 그 값은 (-0.5)*2^(`128) 이다.
y축 대칭으로 생각해서 절대값이 가장 큰 음수와 가장 작은 양수는 위의 숫자에 각각 -를 붙여주면 된단다.

물론 저 범위 안에 있다고 실제로 모두 표현 가능한 것은 아니다. 왜냐면 아까처럼 0.2와 같은 숫자는 이진법으로 표현하기가 불가능하기 때문이다.
그러나 표현 가능 범위를 따질 때 이걸 고려하지는 않는다.

- Biased exponent

ex) Bias = 1000_0000이라 치면, 13.625(10) = 1101.101(2) = 0.1101101 * 2^4 를 표기할 때
S와 M은 그대로 S=1, M=101101000...0 인데 E만 원래의 00000100 에 Bias 10000000을 더해준 10000100을 저장해준다.

왜 biased exponent를 써, 난데없이? 소수를 정수와 같은 방법으로 Zero test 하기 위해서다.
E = 1000_0000인 어떤 수는 M의 크기와 관계없이 걍 0이라고 보면 된다. 그러나 zero test는 모든 bit가 0인 녀석만 0으로 인지하므로 E는 0 취급을 못 받는다.
이 때 128인 bias를 더해주면 E가 0000_0000이 되면서 Zero test에 합격할 수 있게 되는 것이다.


2. Double precision(배정밀도) 는 걍 Single에서 사용한 float 대신 double을 사용하므로 64bit기반이고, 그에 따라 11비트짜리 exp와 52비트짜리 Man을 가진다는 차이 밖에 없다. 

--------------------------------------------------------------------------------------------------------------------------------------------

** IEEE 754 standard **

Format이 위의 수와 조금 다르다. Single precision은 (-1)^s x 2^(E-127) x (1.M) 으로, 우선 bias를 127을 쓰고 normalization을 0.1M이 아닌 1.M으로 표현.


-------------------------------------------------------------------------------------------------------------------

**BFPN arithmetic**

위에서 실수의 저장방법을 보았다면, 어떻게 연산하는지 보자.
참고로 정수는 논리, 산술 연산이 다 있지만 실수는 논리연산이 없고 산술 연산만 있다.

- 덧셈/뺄셈
지수를 먼저 맞추고 가수끼리 덧/뺄셈을 해준 뒤 나온 결과를 normalization.

- 곱셈/나눗셈
가수끼리 연산하고 지수끼리 연산. 그리고 normalization.

- 산술연산에서 발생 가능한 문제들
1. exponent overflow: +inf, -inf 로 set.
2. exponent underflow: 0으로 set.
3. mantissa overflow: normalization
4. mantissa underflow: 내림.

